/* Cоздание связанных таблиц*/
CREATE TABLE Departments 
(
    Id INT NOT NULL, 
    Name VARCHAR2(200) NOT NULL,
    CONSTRAINT Departments_Pk PRIMARY KEY (Id)
);

CREATE TABLE Employees 
(
    Id INT NOT NULL, 
    Name VARCHAR2(150) NOT NULL, 
    Surname VARCHAR2(150) NOT NULL, 
    Patronymic VARCHAR2(150) NOT NULL, 
    IsDepartmentHead NUMBER DEFAULT 0 NOT NULL, 
    Birthday DATE NOT NULL, 
    DepartmentId INT NOT NULL,
    CONSTRAINT Employees_Pk PRIMARY KEY (Id),
    CONSTRAINT Employees_DepartmentId_Fk FOREIGN KEY (DepartmentId) REFERENCES Departments(Id)
);

/*Создание таблицы со столбцом с автоинкриментом*/
CREATE TABLE TEST.INVENTORY_REQUESTS 
(
	ID NUMBER(38,0) GENERATED ALWAYS AS IDENTITY START WITH 1 INCREMENT BY 1 NOT NULL,
	CONSTRAINT INVENTORY_REQUESTS_PK PRIMARY KEY (ID)
);
COMMENT ON TABLE TAXFL_TEST.INVENTORY_REQUESTS IS 'Заявки на выполнение инвентаризации';

/* Заполнение связанных таблиц данными*/
INSERT INTO Departments (Id, Name) Values (1, 'Отдел 1');

INSERT INTO Departments (Id , Name)
SELECT 2, 'Отдел 2' FROM dual
UNION
SELECT 3, 'Отдел 3' FROM dual
UNION
SELECT 4, 'Отдел 4' FROM dual
UNION
SELECT 5, 'Отдел 5' FROM dual;

INSERT INTO Employees (Id, Name, Surname, Patronymic, IsDepartmentHead, Birthday, DepartmentId)
SELECT 1, 'Иван', 'Васин','Петрович', 1, TO_DATE('01-12-1990', 'DD-MM-YYYY'), 1 FROM dual
UNION
SELECT 2, 'Антон', 'Трунин','Иванович', 0, TO_DATE('21-01-1983', 'DD-MM-YYYY'), 1 FROM dual
UNION
SELECT 3, 'Пётр', 'Иванов','Сергеевич', 0, TO_DATE('19-06-1981', 'DD-MM-YYYY'), 1 FROM dual
UNION
SELECT 4, 'Сергей', 'Таранов','Петрович', 0, TO_DATE('11-06-1987', 'DD-MM-YYYY'), 2 FROM dual
UNION
SELECT 5, 'Олег', 'Подбельский','Антонович', 1, TO_DATE('05-11-1993', 'DD-MM-YYYY'), 2 FROM dual
UNION
SELECT 6, 'Игорь', 'Антонов','Олегович', 0, TO_DATE('17-03-1989', 'DD-MM-YYYY'), 2 FROM dual
UNION
SELECT 7, 'Иван', 'Сергеев','Анатольевич', 1, TO_DATE('02-09-1979', 'DD-MM-YYYY'), 3 FROM dual
UNION
SELECT 8, 'Алексей', 'Васин','Александрович', 0, TO_DATE('28-12-1935', 'DD-MM-YYYY'), 3 FROM dual
UNION
SELECT 9, 'Иван', 'Никольский','Петрович', 1, TO_DATE('30-12-2001', 'DD-MM-YYYY'), 4 FROM dual
UNION
SELECT 10, 'Иван', 'Трунин','Петрович', 0, TO_DATE('15-12-1950', 'DD-MM-YYYY'), 4 FROM dual
UNION
SELECT 11, 'Иван', 'Таранов','Петрович', 1, TO_DATE('01-08-1980', 'DD-MM-YYYY'), 5 FROM dual;

/* Получение данных из двух таблиц*/
SELECT d.Id, d.Name, Count(e.Id) AS EmployeesCount
FROM Departments d 
LEFT JOIN Employees e 
   ON d.Id = e.DepartmentId
GROUP BY d.Id, d.Name;

/* Работа с CTE */
WITH CteDepartments AS
(
    SELECT d.Id, 
           d.Name
	FROM Departments d
),
CteEmployees AS
(
    SELECT e.Id AS EmployeeId,
           (e.Surname || ' ' || e.Name || ' ' || e.Patronymic) AS Fio,
           e.DepartmentId
	FROM Employees e
)

SELECT dep.Id, dep.Name, emp.EmployeeId, emp.Fio
FROM CteDepartments dep
INNER JOIN CteEmployees emp 
   ON dep.Id = emp.DepartmentId;
   
--CTE и MERGE

MERGE INTO products_target target
USING 
(  WITH cleaned_source AS (
		SELECT 
			product_id,
			product_name,
			price,
			category
		FROM products_source
		WHERE price > 0  -- фильтруем некорректные цены
		-- убираем дубли, оставляя самую свежую запись
		QUALIFY ROW_NUMBER() OVER (PARTITION BY product_id ORDER BY last_updated DESC) = 1
   )
   SELECT *
   from cleaned_source
) source
    ON target.product_id = source.product_id  -- ключ соединения
WHEN MATCHED THEN  -- если товар найден в целевой таблице
    UPDATE SET
        target.product_name = source.product_name,
        target.price = source.price,
        target.category = source.category,
        target.last_updated = CURRENT_TIMESTAMP

WHEN NOT MATCHED THEN  -- если товара нет в целевой таблице
    INSERT (
        product_id,
        product_name,
        price,
        category,
        last_updated
    ) VALUES (
        source.product_id,
        source.product_name,
        source.price,
        source.category,
        CURRENT_TIMESTAMP
    );
   
   
   
/*Информация об объектах БД (dba_source)*/

SELECT *
FROM dba_source
WHERE TYPE = 'PROCEDURE'
		AND NAME  ='EXEC_SQL';
	

/*Информация о функция БД (all_objects)*/	
SELECT 
    *
FROM 
    all_objects 
WHERE 
    object_type = 'FUNCTION' 
    AND object_name LIKE 'F$GETKOD%'
		
/*Информация об изменениях в объектах БД (dba_audit_trail)*/

SELECT *
FROM dba_audit_trail 
WHERE obj_name = 'MyPacTest'
ORDER BY TIMESTAMP;

/*Информация о последовательности (all_sequences)*/

SELECT *
FROM all_sequences 
WHERE SEQUENCE_OWNER = 'MY_SCHEMA'
      AND SEQUENCE_NAME = 'SEQ$CUSTOMER$ID'

/*Информация о таблице (all_tables)*/  
SELECT *
FROM all_tables 
WHERE OWNER = 'MY_SCHEMA'
      AND TABLE_NAME = 'CUSTOMERS'
	 
/*Информация о индексе (dba_indexes)*/ 	 
SELECT index_name, last_analyzed
FROM dba_indexes
 WHERE TABLE_NAME = 'TABLE_NAME'
        AND index_name = 'INDEX_NAME';	  
	  

/*Информация об изменениях в объектах БД с внесенным кодом(t_audit и t_audit_sql_text)*/

SELECT a.event_datetime, 
       a.OS_USER, 
       a.HOST, 
       a.LOGIN_USER, 
       a.OBJECT_OWNER, 
       a.OBJECT_NAME, 
       a.OBJECT_TYPE,
       a.SYSEVENT, 
       ast.sql_text 
FROM  SU.t_audit a
INNER JOIN SU.t_audit_sql_text ast 
     ON ast.audit_id = a.id
WHERE a.event_datetime > sysdate - 300000 AND 
    --a.object_owner = 'Owner_Name' AND 
      a.object_name = 'MyPacTest'
ORDER BY a.event_datetime DESC

/*Объединения данных из одной таблицы с данными в другой таблице (MERGE)*/

--Мы хотим обновить зарплаты сотрудников в таблице EMPLOYEES на основе данных из таблицы PAYROLLS. 
--Если сотрудник из PAYROLLS не существует в EMPLOYEES, мы хотим добавить его.

--Простой пример 1:

MERGE INTO EMPLOYEES e
USING PAYROLLS p
	ON (e.ID = p.EMPLOYEE_ID)
WHEN MATCHED THEN
    UPDATE SET e.SALARY = p.SALARY
WHEN NOT MATCHED THEN
    INSERT (ID, NAME, DEPARTMENT_ID, SALARY)
    VALUES (p.EMPLOYEE_ID, 'Сотрудник' || p.EMPLOYEE_ID, 1, p.SALARY);
	
/*Преобразования строковых данных в столбцы, что позволяет более удобно представлять данные в отчетах (PIVOT)*/

--Простой пример:

Таблица sales:

PRODUCT|MONTH|AMOUNT|
-------+-----+------+
Apples |Jan  |   100|
Apples |Feb  |   150|
Oranges|Jan  |   250|
Oranges|Feb  |   200|
Bananas|Jan  |   350|
Bananas|Feb  |   190|

SELECT *
FROM SALES
PIVOT (

    SUM(amount) 

    FOR month IN ('Jan' AS January, 'Feb' AS February)

);

PRODUCT|JANUARY|FEBRUARY|
-------+-------+--------+
Bananas|    350|     190|
Apples |    100|     150|
Oranges|    250|     200|


--Значение параметра БД или таблицы (v$parameter)

SELECT *
FROM v$parameter

/*Оконные функции*/

--Максимальная зарплата сотрудников (MAX)
 
 -- С помощью оконной функции
 
SELECT e.ID , e.NAME, e.DEPARTMENT_ID, e.HIRE_DATE,  
       MAX(e.SALARY) OVER() AS SALARY_MAX
FROM EMPLOYEES e; 

ID|NAME       |DEPARTMENT_ID|HIRE_DATE                    |SALARY_MAX|
--+-----------+-------------+-----------------------------+----------+
10|Сотрудник10|            1|2025-03-01 00:00:00.000 +0300|    300000|
 4|Андрей     |            3|2025-02-01 00:00:00.000 +0300|    300000|
 5|Александр  |            1|2025-01-01 00:00:00.000 +0300|    300000|
 6|Олег       |            1|2024-12-12 00:00:00.000 +0300|    300000|
 1|Иван       |            1|2025-03-01 00:00:00.000 +0300|    300000|
 2|Пётр       |            1|2025-03-01 00:00:00.000 +0300|    300000|
 3|Антон      |            2|2025-03-01 00:00:00.000 +0300|    300000|
 
 Мы применяем оконную функцию over(). 
 Используем её для получения максимальной зарплаты по всей организации, так как не указаны размеры “окна”. 
 Over() с пустыми скобками применяется для всей выборки. 
 Поэтому везде максимальная зарплата — 300 000. 
 Результат действия оконной функции добавляется к каждой строчке. 
 
 
 --Без оконной функции
 
WITH Cte AS
(SELECT MAX(e.SALARY) AS SALARY_MAX
FROM EMPLOYEES e)
SELECT e.ID , e.NAME, e.DEPARTMENT_ID, e.HIRE_DATE, Cte.SALARY_MAX
FROM EMPLOYEES e
CROSS JOIN Cte;

ID|NAME       |DEPARTMENT_ID|HIRE_DATE                    |SALARY_MAX|
--+-----------+-------------+-----------------------------+----------+
10|Сотрудник10|            1|2025-03-01 00:00:00.000 +0300|    300000|
 4|Андрей     |            3|2025-02-01 00:00:00.000 +0300|    300000|
 5|Александр  |            1|2025-01-01 00:00:00.000 +0300|    300000|
 6|Олег       |            1|2024-12-12 00:00:00.000 +0300|    300000|
 1|Иван       |            1|2025-03-01 00:00:00.000 +0300|    300000|
 2|Пётр       |            1|2025-03-01 00:00:00.000 +0300|    300000|
 3|Антон      |            2|2025-03-01 00:00:00.000 +0300|    300000|


--Максимальная зарплата сотрудников в рамках отдела (MAX и PARTITION BY)

SELECT e.ID , e.NAME, e.DEPARTMENT_ID, e.HIRE_DATE,  
       MAX(e.SALARY) OVER(PARTITION BY e.DEPARTMENT_ID) AS SALARY_MAX
FROM EMPLOYEES e; 

ID|NAME       |DEPARTMENT_ID|HIRE_DATE                    |SALARY_MAX|
--+-----------+-------------+-----------------------------+----------+
10|Сотрудник10|            1|2025-03-01 00:00:00.000 +0300|    255000|
 6|Олег       |            1|2024-12-12 00:00:00.000 +0300|    255000|
 2|Пётр       |            1|2025-03-01 00:00:00.000 +0300|    255000|
 5|Александр  |            1|2025-01-01 00:00:00.000 +0300|    255000|
 1|Иван       |            1|2025-03-01 00:00:00.000 +0300|    255000|
 3|Антон      |            2|2025-03-01 00:00:00.000 +0300|    300000|
 4|Андрей     |            3|2025-02-01 00:00:00.000 +0300|    255000|
 
 Мы использовали PARTITION BY, которое позволило задать размеры нашего окна. 


--Кол-во строк к группе (COUNT и PARTITION BY)

SELECT  DISTINCT e.department_id, 
                 d.NAME AS DEPARTMENT_NAME,
                 COUNT(e.id) OVER (PARTITION BY e.department_id) AS employees_count
FROM 
    employees e
INNER JOIN DEPARTMENTS d 
   ON e.DEPARTMENT_ID = d.ID
 ORDER BY e.department_id;
 
 DEPARTMENT_ID|DEPARTMENT_NAME    |EMPLOYEES_COUNT|
-------------+-------------------+---------------+
            1|Отдел разработки   |              5|
            2|Отдел сопровождения|              1|
            3|Отдел бухгалтерии  |              1|
   
   
PARTITION BY e.department_id для каждой строки выборки создает "окно" (или группу) в которое входят строки с одинаковыми значениями department_id и 
для них выполняется функция COUNT(e.id)
   
   
--Ранжирование строк (RANK)

--Функция RANK() в Oracle используется для присвоения рангов строкам в наборе данных на основе значений в определенном столбце. 
--Если несколько строк имеют одинаковые значения, они получают одинаковый ранг, и следующий ранг пропускается.

ID|NAME       |DEPARTMENT_ID|SALARY|
--+-----------+-------------+------+
10|Сотрудник10|            1|100000|
 4|Андрей     |            3|255000|
 1|Иван       |            1|255000|
 2|Пётр       |            1|150000|
 3|Антон      |            2|300000|
 5|Александр  |            1|255000|
 6|Олег       |            1|150000|
 
 
SELECT  e.ID,
        e.Name,
        e.SALARY,
        RANK() OVER(ORDER BY SALARY) AS SALARY_RANK
		--,ROW_NUMBER() OVER(ORDER BY SALARY) AS ROW_NUMBER
FROM 
    employees e
	
ID|NAME       |SALARY|SALARY_RANK|
--+-----------+------+-----------+
10|Сотрудник10|100000|          1|    1
 6|Олег       |150000|          2|    2
 2|Пётр       |150000|          2|    3 <--- заменяется на 2
 1|Иван       |255000|          4|    4
 5|Александр  |255000|          4|    5 <--- заменяется на 4
 4|Андрей     |255000|          4|    6 <--- заменяется на 4
 3|Антон      |300000|          7|    7
 
 
--Средняя зарплата сотрудников отдела (AVG)

SELECT d.ID,
       d.NAME,
       e.NAME AS EMPLOYEE_NAME,
       e.HIRE_DATE,
       e.SALARY,
       AVG(e.SALARY) OVER(PARTITION BY d.ID) AS AVG_SALARY_BY_DEPARTMENT
FROM DEPARTMENTS d 
   INNER JOIN EMPLOYEES e 
      ON d.ID = e.DEPARTMENT_ID
	  
ID|NAME               |EMPLOYEE_NAME|HIRE_DATE                    |SALARY|AVG_SALARY_BY_DEPARTMENT|
--+-------------------+-------------+-----------------------------+------+------------------------+
 1|Отдел разработки   |Сотрудник10  |2025-03-01 00:00:00.000 +0300|100000|                  182000|
 1|Отдел разработки   |Олег         |2024-12-12 00:00:00.000 +0300|150000|                  182000|
 1|Отдел разработки   |Пётр         |2025-03-01 00:00:00.000 +0300|150000|                  182000|
 1|Отдел разработки   |Александр    |2025-01-01 00:00:00.000 +0300|255000|                  182000|
 1|Отдел разработки   |Иван         |2025-03-01 00:00:00.000 +0300|255000|                  182000|
 2|Отдел сопровождения|Антон        |2025-03-01 00:00:00.000 +0300|300000|                  300000|
 3|Отдел бухгалтерии  |Андрей       |2025-02-01 00:00:00.000 +0300|255000|                  255000|
 
 
/*Получить список всех прав для указанного пользователя*/

SELECT *
FROM (
    SELECT GRANTEE AS USERNAME,
           GRANTED_ROLE AS PRIVILEGE,
           '--' AS OWNER,
           '--' AS TABLENAME,
           '--' AS COLUMN_NAME,
           ADMIN_OPTION,
           'ROLE' AS ACCESS_TYPE
    FROM DBA_ROLE_PRIVS
    WHERE GRANTEE = UPPER('user_name')
    
    UNION
    
    SELECT GRANTEE AS USERNAME,
           PRIVILEGE,
           '--' AS OWNER,
           '--' AS TABLENAME,
           '--' AS COLUMN_NAME,
           ADMIN_OPTION,
           'SYSTEM' AS ACCESS_TYPE
    FROM DBA_SYS_PRIVS
    WHERE GRANTEE = UPPER('user_name')
    
    UNION
    
    SELECT GRANTEE AS USERNAME,
           PRIVILEGE,
           OWNER,
           TABLE_NAME AS TABLENAME,
           '--' AS COLUMN_NAME,
           GRANTABLE AS ADMIN_OPTION,
           'TABLE' AS ACCESS_TYPE
    FROM DBA_TAB_PRIVS
    WHERE GRANTEE = UPPER('user_name')
    
    UNION
    
    SELECT DP.GRANTEE AS USERNAME,
           PRIVILEGE,
           OWNER,
           TABLE_NAME AS TABLENAME,
           COLUMN_NAME,
           '--' AS ADMIN_OPTION,
           'ROLE' AS ACCESS_TYPE
    FROM ROLE_TAB_PRIVS RP, DBA_ROLE_PRIVS DP
    WHERE RP.ROLE = DP.GRANTED_ROLE
      AND DP.GRANTEE = UPPER('user_name')
    
    UNION
    
    SELECT GRANTEE AS USERNAME,
           PRIVILEGE,
           GRANTABLE AS ADMIN_OPTION,
           OWNER,
           TABLE_NAME AS TABLENAME,
           COLUMN_NAME,
           'COLUMN' AS ACCESS_TYPE
    FROM DBA_COL_PRIVS
    WHERE GRANTEE = UPPER('user_name')
) A
ORDER BY USERNAME,
         A.TABLENAME,
         CASE
             WHEN A.ACCESS_TYPE = 'SYSTEM' THEN 1
             WHEN A.ACCESS_TYPE = 'TABLE' THEN 2
             WHEN A.ACCESS_TYPE = 'COLUMN' THEN 3
             WHEN A.ACCESS_TYPE = 'ROLE' THEN 4
             ELSE 5
         END,
         CASE
             WHEN A.PRIVILEGE IN ('EXECUTE') THEN 1
             WHEN A.PRIVILEGE IN ('SELECT', 'INSERT', 'DELETE') THEN 3
             ELSE 2
         END,
         A.COLUMN_NAME,
         A.PRIVILEGE;
		 
/*Отображение информации в консоли DBMS_OUTPUT.PUT_LINE*/

-- Включаем вывод
SET SERVEROUTPUT ON;

-- PL/SQL-блок
DECLARE
    my_variable NUMBER := 42;  -- Объявляем и инициализируем переменную
BEGIN
    DBMS_OUTPUT.PUT_LINE('Значение переменной: ' || my_variable);
END;
/

/*Работа с JSON*/

--Для примеров нужно выполнить следующие команды

CREATE TABLE TEST.JSON_EXAMPLES (
	ID INTEGER NOT NULL,
	JSON_DATA VARCHAR2(4000) NOT NULL,
	CONSTRAINT JSON_EXAMPLES_ID_PK PRIMARY KEY (ID)
);

INSERT INTO TEST.JSON_EXAMPLES (ID, JSON_DATA) 
VALUES(1, '{"departments":[{"name":"ИТ","начальник":"Иванов Иван Иванович","employees":[{"id":1,"name":"Сидоров Петр Петрович","position":"Ведущий разработчик","salary":250000},{"id":2,"name":"Короткова Елена Ивановна","position":"Тестировщик","salary":100000}]},{"name":"HR","начальник":"Динисова Ольга Николаевна","employees":[{"id":3,"name":"Туманов Антон Григорьевич","position":"HR специалист","salary":160000}]}]}');

--1. Базовое извлечение: Простые скалярные значения (JSON_VALUE)

-- Пример 1: Извлечение названия первого отдела
SELECT 
    ID,
    JSON_VALUE(JSON_DATA, '$.departments[0].name') AS department_name
FROM TEST.JSON_EXAMPLES
WHERE ID = 1;

-- Пример 2: Извлечение зарплаты первого сотрудника в первом отделе
SELECT 
    ID,
    JSON_VALUE(JSON_DATA, '$.departments[0].employees[0].salary') AS employee_salary
FROM TEST.JSON_EXAMPLES
WHERE ID = 1;

Примечания:
    - Пути используют синтаксис JSONPath (например, $ — корень, [0] — первый элемент массива).
    - Если путь не существует, возвращается NULL (используйте клаузу RETURNING для обработки ошибок, например, ERROR ON ERROR).
	
--2. "Расплющивание" JSON: Использование JSON_TABLE для табличных результатов 

--Пример 1: Извлечение всех сотрудников из всех отделов 

SELECT jt.*   
FROM TEST.JSON_EXAMPLES t,
     JSON_TABLE
     (
         t.JSON_DATA,
         '$.departments.employees[*]'
         COLUMNS (
             EMPLOYEE_ID VARCHAR2(100) PATH '$.id',
             EMPLOYEE_NAME VARCHAR2(2000) PATH '$.name',
             EMPLOYEE_POSITION VARCHAR2(2000) PATH '$.position',
             EMPLOYEE_SALARY  VARCHAR2(100) PATH '$.salary'
             
         )
     ) jt
	 
--Пример 2: Извлечение всех отделов

SELECT jt.*
FROM TEST.JSON_EXAMPLES t,
     JSON_TABLE
     (
         t.JSON_DATA,
         '$.departments[*]'
         COLUMNS (
             DEPARTMENT_NAME VARCHAR2(2000) PATH '$.name',
             MANAGER VARCHAR2(2000) PATH '$.manager'
            
         )
     ) jt
	 
--Пример 3: Извлечение всех отделов и их сотрудников (большая плоская таблица).

SELECT jt.*
FROM TAXFL_TEST.JSON_EXAMPLES t,
     JSON_TABLE
     (
         t.JSON_DATA,
         '$.departments[*]'
         COLUMNS (
             DEPARTMENT_NAME VARCHAR2(2000) PATH '$.name',
             MANAGER VARCHAR2(2000) PATH '$.manager',
             NESTED PATH '$.employees[*]'
             COLUMNS (
	             EMPLOYEE_ID VARCHAR2(100) PATH '$.id',
	             EMPLOYEE_NAME VARCHAR2(2000) PATH '$.name',
	             EMPLOYEE_POSITION VARCHAR2(2000) PATH '$.position',
	             EMPLOYEE_SALARY  VARCHAR2(100) PATH '$.salary'
         	) 
         )
     ) jt
	 
--Пример 4:

SELECT 
    jt."Id",
    jt."Description"
FROM (
    SELECT '[{"Id":1,"Description":"Описание 1"},{"Id":2,"Description":"Описание 2"}]' AS json_str
    FROM dual
) t,
JSON_TABLE(
    t.json_str,
    '$[*]'  -- путь к каждому элементу массива
    COLUMNS (
        "Id" NUMBER(10) PATH '$.Id',
        "Description" VARCHAR2(250) PATH '$.Description'
    )
) jt;	 
	 
-- 3. Фильтрация данных

--Пример 1: Фильтрация после разбора JSON

SELECT jt.*
FROM TAXFL_TEST.JSON_EXAMPLES t,
     JSON_TABLE
     (
         t.JSON_DATA,
         '$.departments[*]'
         COLUMNS (
             DEPARTMENT_NAME VARCHAR2(2000) PATH '$.name',
             MANAGER VARCHAR2(2000) PATH '$.manager',
             NESTED PATH '$.employees[*]'
             COLUMNS (
	             EMPLOYEE_ID VARCHAR2(100) PATH '$.id',
	             EMPLOYEE_NAME VARCHAR2(2000) PATH '$.name',
	             EMPLOYEE_POSITION VARCHAR2(2000) PATH '$.position',
	             EMPLOYEE_SALARY  VARCHAR2(100) PATH '$.salary'
         	) 
         )
     ) jt
 WHERE jt.DEPARTMENT_NAME = 'ИТ'
 
--Пример 2: Фильтрация перед разбором JSON (json_exists)
 
SELECT jt.*
FROM 
(
	SELECT t.*
	FROM TAXFL_TEST.JSON_EXAMPLES t
	  WHERE json_exists(t.JSON_DATA ,
	                    '$?(@.departments.name == "ИТ")')
) r,
 JSON_TABLE
 (
     r.JSON_DATA,
     '$.departments[*]'
     COLUMNS (
         DEPARTMENT_NAME VARCHAR2(2000) PATH '$.name',
         MANAGER VARCHAR2(2000) PATH '$.manager',
         NESTED PATH '$.employees[*]'
         COLUMNS (
             EMPLOYEE_ID VARCHAR2(100) PATH '$.id',
             EMPLOYEE_NAME VARCHAR2(2000) PATH '$.name',
             EMPLOYEE_POSITION VARCHAR2(2000) PATH '$.position',
             EMPLOYEE_SALARY  VARCHAR2(100) PATH '$.salary'
     	) 
     )
 ) jt
 
-- 4. Формирование строки JSON по выборке

SELECT JSON_OBJECT(
    'Id'         VALUE 1,
    'CreateDate' VALUE TO_DATE('2024.05.01','YYYY.MM.DD'),
	'DeleteDate' VALUE NULL
) AS json_row
FROM dual; 
 
/* Работа с датами*/
 
 -- Получение даты из строки (TO_DATE)
 
 SELECT TO_DATE('2023-10-15', 'YYYY-MM-DD') AS my_date, 
        TO_DATE('2023-10-15 13:04:12', 'YYYY-MM-DD HH24:MI:SS') AS my_datetime
 FROM dual;
 
 -- Получение текущей даты (Функция SYSDATE)  
 -- SYSDATE - Возвращает системную дату и время сервера БД (независимо от часового пояса сеанса).
 
 SELECT SYSDATE 
 FROM DUAL;
 
 -- Преобразование даты и время в строку указанного формата
 
 SELECT TO_CHAR(TO_DATE('2023-10-15 13:04:12', 'YYYY-MM-DD HH24:MI:SS'), 'DD.MM.YYYY HH24:MI:SS')
 FROM DUAL;
 
 
/* Работа с правами доступа */
 
grant execute on CUSTOM_PROCEDURE_NAME to CURRENT_SCHEMA_NAME with grant option;                -- доступ на вызов пользовательской хранимой процедуры (CUSTOM_PROCEDURE_NAME) из схемы (CURRENT_SCHEMA_NAME)
grant execute on function schema_name.function_name to target_schema with grant option;         -- доступ на вызов пользовательской функции
grant select on REMOTE_SCHEMA_NAME.TABLE_NAME to CURRENT_SCHEMA_NAME with grant option;         -- доступ на выбор из чужой схемы (REMOTE_SCHEMA_NAME) таблицы (TABLE_NAME) из схемы (CURRENT_SCHEMA_NAME)
grant select on REMOTE_SCHEMA_NAME.SEQ$CUSTOMERS$ID to CURRENT_SCHEMA_NAME with grant option;   -- доступ на использование последовательности (sequence) 

/* Работа с коллекцией элементов пользовательского типа*/

--1. Создать пользовательский тип

CREATE TYPE MyShema.Department AS OBJECT (
    id NUMBER,
    name VARCHAR2(500)
);

--2. Создаем тип коллекции

CREATE TYPE MyShema.Departments AS TABLE OF MyShema.Department;

--3. Создаем саму хранимую процедуру

CREATE OR REPLACE PROCEDURE MyShema.Get_Departments(
    departments OUT MyShema.Departments
) AS
BEGIN
    -- Непосредственный SELECT с BULK COLLECT
    SELECT 
        MyShema.Department(t.id, t.name)
    BULK COLLECT INTO departments
    FROM Departments t;
	
    -- Если данных нет, коллекция будет пустой автоматически
    -- Дополнительная проверка не требуется
    
END MyShema.Get_Departments;

--4. Вызов процедуры и получение данных

DECLARE
     t_departments MyShema.Departments;
BEGIN
	MyShema.Get_DepartmentsS(
        departments => t_departments
    );
	
    IF t_departments.COUNT > 0 THEN
        FOR i IN 1..t_departments.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE('ID: ' || t_departments(i).Id || ', Name: ' || t_departments(i).Name);
        END LOOP;
    ELSE
        DBMS_OUTPUT.PUT_LINE('Данных не найдено');
    END IF;

END;

--5. Замены PL/SQL на SQL

-- 5.1 Замена цикла на один SQL‑запрос:

--  Через CONNECT BY (классический способ и быстрый):

SELECT 
    CUSTOM_FUNC_1( 
		0,
        TO_DATE('01.01.2026', 'DD.MM.YYYY'), level - 1)
    ) AS v_end_date
FROM
    dual
CONNECT BY
    level <= 6;
	
Как это работает:

    level — псевдостолбец, который автоматически увеличивается на 1 при каждом шаге рекурсии.
	   level − 1 сделано, чтобы итерация началась с 0,а не с 1.

    CONNECT BY level <= 6 — ограничивает количество итераций до 6 (как v_month_count)
	
--6. Работа с UDT

--6.1 Создание UDT

CREATE OR REPLACE TYPE SCHEMA_NAME.TYPE_NAME FORCE AS OBJECT (
    ID              NUMBER(5),           -- ИД           
    REPORT_YEAR     NUMBER(4),           -- Отчетный год               
    DESCRIPTION     VARCHAR2(255 CHAR),  -- Примечание                    
    
    CONSTRUCTOR FUNCTION TYPE_NAME
        RETURN SELF AS RESULT
);
/
CREATE OR REPLACE TYPE BODY SCHEMA_NAME.TYPE_NAME IS
    CONSTRUCTOR FUNCTION TYPE_NAME
        RETURN SELF AS RESULT IS
    BEGIN

      
        RETURN;  
    END;
END;
/

-- 6. Генерация случайных чисел

-- 6.1 Случайная строка

SELECT 'ИНВ от ' || TO_CHAR(TO_DATE('2023-10-15 13:04:12', 'YYYY-MM-DD HH24:MI:SS'), 'DD.MM.YYYY') 
				 || ' ' || DBMS_RANDOM.STRING('U', 4)    -- 4 заглавные буквы
FROM DUAL;	

'A' — смешанный регистр букв и цифр;
'U' — только заглавные буквы;
'L' — только строчные буквы;
'X' — заглавные буквы и цифры.			
				   
-- 6.2 Уникальный GUID

SELECT 'ИНВ_' || TO_CHAR(SYSDATE, 'YYYYMMDD') || '_' || SYS_GUID()
FROM DUAL;

-- 6.3 Случайное целое число из диапазона

SELECT FLOOR(DBMS_RANDOM.VALUE(1, 999))
FROM DUAL;

-- 6.4 Случайная дата и время из диапазона

SELECT SYSDATE + DBMS_RANDOM.VALUE(-30, 30)  --Результат: дата ± 30 дней от текущей
FROM DUAL;


-- 7. Обмен сообщений между хранимыми процедурами и асинхронным их выполнением

-- 7.1 Дать права на схему

GRANT EXECUTE ON SYS.DBMS_AQ TO TEST;
GRANT EXECUTE ON SYS.DBMS_AQADM TO TEST;

BEGIN
    DBMS_AQADM.GRANT_QUEUE_PRIVILEGE(
        privilege    => 'ALL',
        queue_name   => 'TEST.INVENTORY_MSG_QUEUE',
        grantee      => 'TEST',
        grant_option => FALSE
    );
END;

-- 7.2 Сначала создадим очередь для асинхронной передачи сообщений:

BEGIN
    --Создаётся таблица очередей — специальная структура для хранения сообщений.
    DBMS_AQADM.CREATE_QUEUE_TABLE(
        queue_table => 'TEST.INVENTORY_MSG_QT',
        queue_payload_type => 'SYS.AQ$_JMS_TEXT_MESSAGE'
    );

    -- Создаётся сама очередь внутри ранее созданной таблицы очередей
    DBMS_AQADM.CREATE_QUEUE(
        queue_name => 'TEST.INVENTORY_MSG_QUEUE',
        queue_table => 'TEST.INVENTORY_MSG_QT'
    );

    -- Очередь активируется — становится готовой к приёму и отправке сообщений.
    DBMS_AQADM.START_QUEUE( 'TEST.INVENTORY_MSG_QUEUE');
END;
/

-- queue_table  - параметр, содержащий имя таблицы, хранящей сообщения (TEST.INVENTORY_MSG_QT)
-- queue_payload_type - параметр задает тип данных в котором будет храниться сообщения (SYS.AQ$_JMS_TEXT_MESSAGE).
--                      SYS.AQ$_JMS_TEXT_MESSAGE стандартный тип Oracle для текстовых сообщений (в формате JMS);

-- 7.3 Доработка первой процедуры отправителя

-- =========================================================================================================================
-- Author:		saa
-- Create date: 21.12.2025
-- Update date: 
-- Description: Создает заявку на выполнение инвентаризации.
-- Input params:
--   request_number:      Номер заявки.
--   request_created_at:  Дата и время создания заявки.
--   request_description: Описание заявки.
-- version: 1.00.00
-- History:
-- ==========================================================================================================================
PROCEDURE P$CREATE_INV_REQUEST
(
     request_number      IN NUMBER,
     request_created_at  IN TIMESTAMP WITH TIME ZONE,
     request_description IN VARCHAR2
)
AS
    v_request_created_state NUMBER  := 1;
    v_request_created_info  VARCHAR2(30 CHAR) := 'Заявка успешно создана';
	v_message               SYS.AQ$_JMS_TEXT_MESSAGE;                      -- Переменная для сообщения
    v_enqueue_options       DBMS_AQ.ENQUEUE_OPTIONS_T;                     -- Настройки отправки
    v_message_properties    DBMS_AQ.MESSAGE_PROPERTIES_T;                  -- Свойства сообщения
    v_msgid                 RAW(16);                                       -- ID сообщения после отправки
    v_request_id            NUMBER;
BEGIN
	
	-- 1. Создаём заявку в таблице INVENTORY_REQUESTS
	INSERT INTO TEST.INVENTORY_REQUESTS (NUM, CREATED_AT, STATE_ID, DESCRIPTION, PROCESSING_INFO)
	VALUES (request_number,
	       request_created_at,
	       v_request_created_state,
	       request_description,
	       v_request_created_info)
	RETURNING ID INTO v_request_id; -- Получаем сгенерированный ID
	
	-- 2. Инициализируем объект сообщения для очереди
	-- Создаёт пустой объект сообщения типа JMS Text Message
    -- Этот тип выбран, потому что позволяет передавать текстовые данные (в т. ч. JSON)
    v_message := SYS.AQ$_JMS_TEXT_MESSAGE.CONSTRUCT;

	-- 3. Заполняем сообщение данными для следующей процедуры
	v_message.set_text('{"request_id": ' || v_request_id || '}');
	
	-- 4. Отправляем сообщение в очередь
	DBMS_AQ.ENQUEUE(
        queue_name          => 'TEST.INVENTORY_MSG_QUEUE',        -- Имя очереди
        enqueue_options     => v_enqueue_options,                 -- Настройки отправки (по умолчанию)
        message_properties => v_message_properties,               -- Свойства сообщения (по умолчанию)
        payload            => v_message,                          -- Само сообщение (JSON)
        msgid              => v_msgid                             -- Получаем ID отправленного сообщения
    );
	
	-- 5. Фиксируем транзакцию
	-- Важно: COMMIT обязателен для завершения операции ENQUEUE
    -- Без COMMIT сообщение не появится в очереди
    -- Если INSERT или ENQUEUE завершатся ошибкой, вся транзакция будет откачена
    COMMIT;
	     
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
		 
END P$CREATE_INV_REQUEST;

-- 7.4 Доработка второй процедуры получателя (отправител)

-- =========================================================================================================================
-- Author:		saa
-- Create date: 21.12.2025
-- Update date: 
-- Description: Создает инвентаризацию.
-- Input params:
--   request_id:            ИД заявки.
-- version: 1.00.00
-- History:
-- ==========================================================================================================================
PROCEDURE P$CREATE_INVENTORY
(
     request_id            IN NUMBER
)
AS
    v_request_created_state NUMBER  := 2;
    v_request_created_info  VARCHAR2(30 CHAR) := 'Начало работ по заявки';
    v_inventory_created_at  TIMESTAMP WITH TIME ZONE;
    v_inventory_number      VARCHAR2(1000 CHAR);
    v_inventory_item_count  NUMBER(6);
    v_inventory_amount      NUMBER(19, 4);
    v_message               SYS.AQ$_JMS_TEXT_MESSAGE;
    v_dequeue_options       DBMS_AQ.DEQUEUE_OPTIONS_T;
    v_message_properties    DBMS_AQ.MESSAGE_PROPERTIES_T;
    v_msgid                 RAW(16);
	v_out_message SYS.AQ$_JMS_TEXT_MESSAGE := SYS.AQ$_JMS_TEXT_MESSAGE.CONSTRUCT;  
    v_out_options DBMS_AQ.ENQUEUE_OPTIONS_T;  
    v_out_props DBMS_AQ.MESSAGE_PROPERTIES_T;  
    v_out_msgid RAW(16);  
	v_err_message SYS.AQ$_JMS_TEXT_MESSAGE;  -- Объект сообщения об ошибке
    v_err_options DBMS_AQ.ENQUEUE_OPTIONS_T; 
    v_err_props DBMS_AQ.MESSAGE_PROPERTIES_T; 
    v_err_msgid RAW(16); 
BEGIN
		
	 -- 1. Попытка получения данных из очереди: 
	 -- 1.1 Настройка получения данных: берём первое сообщение, не ждём, если очереди нет
	 v_dequeue_options.navigation := DBMS_AQ.FIRST_MESSAGE;
     v_dequeue_options.wait := DBMS_AQ.NO_WAIT;
	
	 BEGIN
        -- 1.2 Пытаемся прочитать сообщение из очереди INVENTORY_MSG_QUEUE
        DBMS_AQ.DEQUEUE(
            queue_name          => 'TEST.INVENTORY_MSG_QUEUE',
            dequeue_options     => v_dequeue_options,
            message_properties => v_message_properties,
            payload            => v_message,
            msgid              => v_msgid
        );
        COMMIT;  -- Фиксируем операцию чтения
     EXCEPTION
        WHEN DBMS_AQ.NO_MESSAGE THEN
            NULL; -- Если сообщений нет, просто продолжаем выполнение (ошибка игнорируется)
     END;
	 
	 -- 2. Имитация длительной обработки ( Задержка 5 секунд для демонстрации)
     DBMS_SESSION.SLEEP(5);
	 
	 -- 3. Определения данных инвентаризации и сохранение её в таблицу
	 v_inventory_created_at := SYSDATE;
	 v_inventory_number := 'ИНВ от ' || TO_CHAR(v_inventory_created_at, 'DD.MM.YYYY') 
	                                 || ' ' || DBMS_RANDOM.STRING('U', 4);
	 v_inventory_item_count := FLOOR(DBMS_RANDOM.VALUE(1, 999));
	 v_inventory_amount     := FLOOR(DBMS_RANDOM.VALUE(1, 999999));
	 
	 INSERT INTO TEST.INVENTORIES (NUM, CREATED_AT, ITEM_COUNT, AMOUNT)
	 SELECT v_inventory_number,
	        v_inventory_created_at,
	        v_inventory_item_count,
	        v_inventory_amount 
	 FROM DUAL;
	 
	 --4. Отправка сообщения об успешном завершении в очередь
     v_out_message := SYS.AQ$_JMS_TEXT_MESSAGE.CONSTRUCT;       
     v_out_message.set_text('{"request_id": ' || request_id || ', "state_id": 3, "commentary": "Инвентаризация успешно создана"}');

     -- Отправляем сообщение в очередь INVENTORY_MSG_QUEUE
     DBMS_AQ.ENQUEUE(
        queue_name          => 'TEST.INVENTORY_MSG_QUEUE',
        enqueue_options     => v_out_options,
        message_properties => v_out_props,
        payload            => v_out_message,
        msgid              => v_out_msgid
     );

     COMMIT;  -- Фиксация всех изменений
	      

EXCEPTION
    -- 5. Обработка ошибок
    WHEN OTHERS THEN
        -- В случае любой ошибки отправляем сообщение о неудаче в очередь
        v_err_message := SYS.AQ$_JMS_TEXT_MESSAGE.CONSTRUCT;  -- Объект сообщения об ошибке

        -- Формируем текст сообщения: ID заявки, статус -1 (ошибка), описание ошибки из SQLERRM
        v_err_message.set_text('{"request_id": ' || request_id || ', "state_id": 4, "commentary": "Ошибка при создании инвентаризации"}');

        -- Отправляем сообщение об ошибке в очередь
        DBMS_AQ.ENQUEUE(
            queue_name          => 'TEST.INVENTORY_MSG_QUEUE',
            enqueue_options     => v_err_options,
            message_properties => v_err_props,
            payload            => v_err_message,
            msgid              => v_err_msgid
        );
        COMMIT;  -- Фиксируем отправку сообщения об ошибке
        END;
        RAISE;  -- Передаём исключение выше для дальнейшей обработки     
     
END P$CREATE_INVENTORY;